{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"libRL: A Python library for the characterization of microwave absorption This site is a docstring repository for the libRL library, written by Michael Green at the University of Missouri-Kansas City. Use the tabs on the left-hand side of the page to navigate to the various document sections. Research was supported by the National Science Foundation under grant NSF-1609061. Connect: Michael Green ( @GitHub , @StackOverflow )","title":"Home"},{"location":"__init__/","text":"__init__.py reflection_loss libRL.reflection_loss( data=None, f_set=None, d_set=None, **kwargs ) the reflection_loss (RL) function calculates the RL based on the mapping passed through as the grid variable, done either through multiprocessing or through the python built-in map() function. The RL function always uses the interpolation function, even though as the function passes through the points associated with the input data, solving for the function at the associated frequencies yields the data point. This is simply for simplicity. Reference: Recent Progress in Nanomaterials for Microwave Absorption :param data: (data) Permittivity and Permeability data of Nx5 dimensions. Can be a string equivalent to the directory and file name of either a .csv or .xlsx of Nx5 dimensions. Text above and below data array will be automatically avoided by the program (most network analysis instruments report data which is compatible with the required format) :param f_set: (start, end, [step]) tuple for frequency values in GHz - or - if given as list of len 3, results are interpolated if given as list of len 2, results are data-derived with the calculation bound by the given start and end frequencies if f_set is None, frequency is bound to input data :param d_set: (start, end, step) tuple for thickness values in mm. - or - if d_set is of type list, then the thickness values calculated will only be of the values present in the list. :param kwargs: :interp=: ('cubic'); 'linear' Method for interpolation. Set to linear if user wants to linear interp instead of cubic spline. Default action uses cubic spline. :param kwargs: :override=: (None); 'chi zero'; 'eps set' provides response simulation functionality within libRL, common for discerning which EM parameters are casual for reflection loss. 'chi zero' sets mu = (1-j\u00b70). 'eps set' sets epsilon = (avg(e1)-j\u00b70). :param kwargs: :multiprocessing=: (False); True; 0; 1; 2; ... Method for activating multiprocessing functionality for faster run times. This **kwarg takes integers and booleans. Set variable to True or 0 to use all available nodes. Pass an integer value to use (int) nodes. Will properly handle 'False' as an input though it's equivalent to not even designating the particular **kwarg . NOTE: if you use the multiprocessing functionality herein while on a Windows computer you MUST MUST MUST MUST provide main module protection via the if __name__ == \"__main__\": conditional so to negate infinite spawns. :param kwargs: :quick_graph=: (False); True, str() saves a *.png graphical image to a specified location. If set to True, the quick_graph function saves the resulting graphical image to the location of the input data as defined by the data input (assuming that the data was input via a location string. If not, True throws an assertion error). The raw string of a file location can also be passed as the str() argument, if utilized then the function will save the graph at the specified location. :param kwargs: :as_dataframe=: (False); True returns data in a pandas dataframe. This is particularly useful if multicolumn is also set to true. :param kwargs: :multicolumn=: (False); True outputs data in multicolumn form with a numpy array of [RL, f, d] iterated over each of the three columns. - or - if as_dataframe is used, then return value will be a pandas dataframe with columns of name d and indexes of name f. :return: Nx3 data set of [RL, f, d] by default - or - if multicolumn=True, an NxM dataframe with N rows for the input frequency values and M columns for the input thickness values, with pandas dataframe headers/indexes of value f/d respectively. characterization libRL.characterization( data=None, f_set=None, params=\"all\", **kwargs ) the characterization function takes a set or list of keywords in the 'params' variable and calculates the character values associated with the parameter. See 10.1016/j.jmat.2019.07.003 for further details and the function comments below for a full list of keywords. Reference: Recent Progress in Nanomaterials for Microwave Absorption :param data: (data) Permittivity and Permeability data of Nx5 dimensions. Can be a string equivalent to the directory and file name of either a .csv or .xlsx of Nx5 dimensions. Text above and below data array will be automatically avoided by the program (most network analysis instruments report data which is compatible with the required format) :param f_set: (start, end, [step]) tuple for frequency values in GHz - or - if given as list of len 3, results are interpolated if given as list of len 2, results are data-derived with the calculation bound by the given start and end frequencies. if f_set is None, frequency is bound to input data if f_set is of type list, the frequencies calculate will be only the frequencies represented in the list. :param params: A list of string arguments for the parameters the user wants calculated. The available arguments are: [ \"tgde\", # dielectric loss tangent \"tgdu\", # magnetic loss tangent \"Qe\", # dielectric quality factor \"Qu\", # magnetic quality factor \"Qf\", # total quality factor \"ReRefIndx\", # Refractive Index \"ExtCoeff\", # Extinction Coeffecient \"AtnuCnstNm\", # Attenuation Constant (in Np/m) \"AtnuCnstdB\", # Attenuation Constant (in dB/m) \"PhsCnst\", # Phase Constant \"PhsVel\", # Phase Velocity \"Res\", # Resistance \"React\", # Reactance \"Condt\", # Conductivity \"Skd\", # Skin Depth \"Eddy\" # Eddy Current Loss ] if 'all' (default) is passed, calculate everything. :param kwargs: :override=: (None); 'chi zero'; 'eps set' provides response simulation functionality within libRL, common for discerning which EM parameters are casual for reflection loss. 'chi zero' sets mu = (1-j\u00b70). 'eps set' sets epsilon = (avg(e1)-j\u00b70). :param kwargs: :as_dataframe=: (False); True returns the requested parameters as a pandas dataframe with column names as the parameter keywords. :return: NxY data set of the requested parameters as columns 1 to Y with the input frequency values in column zero to N. - or - returns a pandas DataFrame with the requested parameters as column headers, and the frequency values as index headers. band_analysis libRL.band_analysis( data=None, f_set=None, d_set=None, m_set=None, threshold=-10, **kwargs ) the Band Analysis for ReFlection loss (BARF) function uses Permittivity and Permeability data of materials so to determine the effective bandwidth of Reflection Loss. The effective bandwidth is the span of frequencies where the reflection loss is below some proficiency threshold (standard threshold is -10 dB). Program is computationally taxing; thus, efforts were made to push most of the computation to the C-level for faster run times - the blueprints for such are included in the cpfuncs.pyx file which is passed through pyximport(). [and yes, I love you 3000] References: Microwave absorption of aluminum/hydrogen treated titanium dioxide nanoparticles Recent progress of nanomaterials for microwave absorption :param data: (data) Permittivity and Permeability data of Nx5 dimensions. Can be a string equivalent to the directory and file name of either a .csv or .xlsx of Nx5 dimensions. Text above and below data array will be automatically avoided by the program (most network analysis instruments report data which is compatible with the required format) :param f_set: (start, end, [step]) tuple for frequency values in GHz - or - if given as tuple of len 3, results are interpolated if given as tuple of len 2, results are data-derived with the calculation bound by the given start and end frequencies from the tuple is given as int or float of len 1, results are interpolated over the entire data set with a step size of the given tuple value. if f_set is None (default), frequency is bound to input data. :param d_set: (start, end, [step]) tuple for thickness values in mm. - or - if d_set is of type list, then the thickness values calculated will only be of the values present in the list. (is weird, but whatever.) :param m_set: (start, end, [step]) tuple of ints which define the bands to be calculated. - or - if m_set is given as a list [], the explicitly listed band integers will be calculated. :param thrs: -10 Threshold for evaluation. If RL values are below this threshold value, the point is counted for the band. Typical threshold value is -10 dB. :param kwargs: :override=: (None); 'chi zero'; 'edp zero'; 'eps set' provides response simulation functionality within libRL, common for discerning which EM parameters are casual for reflection loss. 'chi zero' sets mu = (1 - j\u00b70). 'eps set' sets epsilon = (avg(e1)-j\u00b70). :param kwargs: :interp=: ('cubic'); 'linear' Method for interpolation. Set to linear if user wants to linear interp instead of cubic spline. :param kwargs: :quick_graph=: (False); True; str() saves a *.png graphical image to a specified location. If set to True, the quick_graph function saves the resulting graphical image to the location of the input data as defined by the data input (assuming that the data was input via a location string. If not, True throws an assertion error). The raw string of a file location can also be passed as the str() argument, if utilized then the function will save the graph at the specified location. :param kwargs: :as_dataframe=: (False); True Formats results into a pandas dataframe with the index labels as the thickness values, the column labels as the band numbers, and the dataframe as the resulting effective bandwidths. :return: returns len(3) tuple with [d_set, band_results, m_set]. the rows of the band_results correspond with the d_set and the columns of the band_results correspond with the m_set. - or - returns the requested dataframe with the band values as column headers and the thickness values as row headers.","title":"__init__.py"},{"location":"__init__/#reflection_loss","text":"","title":"reflection_loss"},{"location":"__init__/#characterization","text":"","title":"characterization"},{"location":"__init__/#band_analysis","text":"","title":"band_analysis"},{"location":"about/","text":"Michael Green is a PhD candidate under the supervision of Dr. Xiaobo Chen at the University of Missouri\u2013Kansas City, Department of Chemistry. He received his Bachelors of Science in chemistry with a minor in mathematics from the University of Idaho in 2016, and his Masters of Science in chemistry from the University of Missouri\u2013Kansas City in 2019. His research interests include the development, characterization, modeling, and application of nanomaterials in light/matter interactions, focusing on photolysis, photocatalysis, and microwave absorption, as well as short-range matter/matter interactions with a focus in physical adsorption. Contact: magwwc@mail.umkc.edu","title":"About"},{"location":"cpfuncs/","text":"cpfuncs.pyx band_analysis_cython libRL.cpfuncs.band_analysis_cython( PnPGrid, mGrid, m_set, d_set, thrs ) The band_analysis_cython function determines the band analysis of materials by tallying the frequency points which satisfy the threshold, and summing the span of their frequencies. :param PnPgrid: (data) PnPgrid is a pre-processed permittivity & permeability array passed from libRL.CARL of shape Nx5 of [freq, e1, e2, mu1, mu2]. :param mGrid: (data) mGrid is a numpy array of d_values calculated from a modified quarter-wavelength function determined from the frequency values of the PnPgrid. :param m_set: (data) m_set is a numpy array of bands passed through from libRL.refactoring.m_set_ref() :param d_set: (data) d_set is a numpy array of thickness values passed through from libRL.refactoring.d_set_ref() :param thrs: (data) thrs is the threshold value to test Reflection loss against for each (f, d) point in the response field, passed through directly from libRL.band_analysis() :return: the effective bandwidth for each thickness value across each requested band.","title":"cpfuncs.pyx"},{"location":"cpfuncs/#band_analysis_cython","text":"","title":"band_analysis_cython"},{"location":"examples/","text":"Examples Here we're going to demonstrate how to call the various functions of the libRL library - both making use of the main functions as well as calling some of the subdirectories that researchers may have interest in. Windows Suppose that from experimentation a researcher has generated a 'paraffin_data.csv' file of the following structure: Transmission Line And Free Space Method 16.0.16092801,,,, Agilent Technologies,E5063A,MY54100168,A.03.71, ,,,, Ch 1,,,, Ports:, 1 & 2,,, Measurement Model:, Reflection/Transmission Mu and Epsilon,,, Sample Holder Type:, Coax/TEM,,, Sample Holder Length:, 99.700000 mm,,, Distance to Sample:, 43.600000 mm,,, Sample Thickness:, 3.040000 mm,,, ... ... ... Date:,\"Thursday, January 25, 2018 14:10:19\",,, frequency(GHz),e',e'',u',u'' 1,2.1976,0.062033333,1.0705,0.063966667 1.34,2.1814,0.0554,1.0681,0.0577 1.68,2.1444,0.0631,1.0942,0.0339 2.02,2.132,0.0493,1.0997,0.0364 2.36,2.1389,0.0457,1.09,0.0281 ... ... ... 16.98,2.202,0.0513,1.0237,-0.0016 17.32,2.19738,0.0587,1.023466667,-0.00285 17.66,2.191617143,0.06263,1.02912381,-0.00323 18,2.185854286,0.06656,1.034780952,-0.00361 This is a typical Nx5 .csv instrument file that researchers might have generated from network analysis (Note: libRL is written to handle tab-separated .csv files as well as .xlsx files) Let's further suppose that this file is located on the desktop, such that the full file path for our data file is the following: C:\\Users\\1mike\\Desktop\\paraffin_data.csv libRL is designed to parse this data file directly from its instrumentation file. To use libRL in RAM analysis, we can simply construct the following script in our favorite IDE to calculate, for example, the reflection loss (RL) as a unit of decibel defined as: RL(dB) = 20 \\cdot log_{10}\\Big|{\\frac{Z_{in}(f, d)-1}{Z_{in}(f, d)+1}}\\Big| RL(dB) = 20 \\cdot log_{10}\\Big|{\\frac{Z_{in}(f, d)-1}{Z_{in}(f, d)+1}}\\Big| Z_{in}(f, d) = \\Big[ \\frac{\\mu'(f) - j \\cdot \\mu''(f)}{\\epsilon'(f) - j \\cdot \\epsilon''(f)} \\Big]^{\\frac{1}{2}} \\cdot tanh \\Big( j \\cdot \\frac{2\\pi f \\cdot d}{c} \\{[\\mu'(f) - j \\cdot \\mu''(f)][\\epsilon'(f) - j \\cdot \\epsilon''(f)] \\} ^{\\frac{1}{2}} \\Big) Z_{in}(f, d) = \\Big[ \\frac{\\mu'(f) - j \\cdot \\mu''(f)}{\\epsilon'(f) - j \\cdot \\epsilon''(f)} \\Big]^{\\frac{1}{2}} \\cdot tanh \\Big( j \\cdot \\frac{2\\pi f \\cdot d}{c} \\{[\\mu'(f) - j \\cdot \\mu''(f)][\\epsilon'(f) - j \\cdot \\epsilon''(f)] \\} ^{\\frac{1}{2}} \\Big) can be calculated from the following script: import libRL results = libRL.reflection_loss( data=r'C:\\Users\\1mike\\Desktop\\paraffin_data.csv', d_set=[3.04] ) This represents the minimal computable function that libRL will calculate over. At minimum, the permittivity and permeability data should be passed, as well as the thickness parameters for calculation [this should make intuitive sense, as RL is calculated over an (f, d) grid space]. The resulting data set is a Nx3 numpy array of the Reflection Loss, frequencies, and thicknesses in columns 0, 1, 2 respectively. Of course, libRL is designed to do much more than just this minimal computation. As permittivity and permeability are farads/meter and henries/meter, the thickness parameter is decoupled from experimentation and thus can be used to calculate RL of thicknesses not explicitly used in measurement. As such, we can pass a tuple of thickness values to generate an array in accordance to numpy.arange() import libRL results = libRL.reflection_loss( data=r'C:\\Users\\1mike\\Desktop\\paraffin_data.csv', d_set=(0,5,1) ) This results in the calculation being mapped over the thickness range of 0-5 mm (libRL includes the upper bound here) at every step of 1 mm. Currently, reflection loss is being calculated using the frequency values in the permittivity and permeability data set. libRL has a protocol however which allows the user to interploate the data such that frequency can be controlled similarly to the thicknesses. import libRL results = libRL.reflection_loss( data=r'C:\\Users\\1mike\\Desktop\\paraffin_data.csv', f_set=(1,18,1), d_set=(0,5,1) ) Here, the resulting calculation returns a data set calculated over the ranges of 1-18 GHz, 0-5 mm at 1 unit intervals. To note, libRL allows for interpolation and not extrapolation . Attempts to use the interpolating functions outside of your experimental bounds throws an error. Traceback (most recent call last): File \"C:\\Users\\1mike\\PycharmProjects\\libRL\\libRL\\refactoring.py\", line 252, in f_set_ref raise SyntaxError(error_msg) SyntaxError: f_set must be of order (start, stop, step) where 'start' and 'stop' are within the bounds of the data There is a set of keyword arguments which libRL.reflection_loss accepts. These keyword areguments are: interp= multiprocessing= multicolumn= as_dataframe= quick_graph= Descriptions of these keyword arguments can be found in the docstrings. The other functions available in the libRL library use the same refactoring protocols for data, f_set, d_set, and m_set. They each have their own keyword arguments and parameter arguments, so researchers are encouraged to look at the documentation provided on this site for each of those functions. Some of the subdirectory functions available which are of convenient use are the file_refactor() and interpolate() functions, which can be found in documentation under libRL/refactoring.py. In brief, file_refactor() is the protocol libRL uses to parse out the file string into actionable data, and interpolate() is the protocol libRL uses to generate the interpolation functions over the actionable data set. Linux this page is still currently under construction. Check back shortly! macOS this page is still currently under construction. Check back shortly!","title":"Examples"},{"location":"examples/#windows","text":"","title":" Windows "},{"location":"examples/#linux","text":"","title":" Linux "},{"location":"examples/#macos","text":"","title":" macOS "},{"location":"library_structure/","text":"Library Structure libRL/ __init__.py # initial executable refactoring.py # Data processing protocols cpfunc.pyx # cython protocols quick_graphs.py # data visualization protocols the main libRL functions are all accessible via the modules init .py method, which are called directly from libRL.","title":"Library Structure"},{"location":"overview/","text":"libRL: A Python library for the characterization of microwave absorption A Python library for characterizing Microwave Absorption. This Library is to include all of the functions and methods developed at the University of Missouri-Kansas City under NSF grant DMR-1609061. The libRL library can be installed via pip and git pip install git+https://github.com/1mikegrn/libRL Where the setup file will automatically check dependencies and install to the main module library. Once installed, simply import the module as normal via import libRL , and query the docstring via libRL? - the docstring includes a list of the available functions for use. The library includes the following main-level functions: libRL.reflection_loss( data=None, f_set=None, d_set=None, **kwargs ) reflection_loss() computes the resultants of Reflection Loss over (f, d) gridspace. libRL.characterization( data=None, f_set=None, params=\"all\", **kwargs ) characterization() yields the calculated results of common formulations within the Radar Absorbing Materials field. libRL.band_analysis( data=None, f_set=None, d_set=None, m_set=None, threshold=-10, **kwargs ) band_analysis() uses given set of permittivity and permeability data in conjuncture with a requested band set to determine the set of frequencies whose reflection losses are below the threshold.","title":"Overview"},{"location":"quick_graphs/","text":"quick_graphs.py quick and dirty default graphing protocols for RL and BARF functions. NOTE: these functions are designed to be technically functional. Users are welcome to use them for as long as they serve them to an acceptable degree, but please note, bug reports to the contents herein must be of a 'technical' nature, and not artistic. If an axis doesn't have the spacing you want or the scale/range doesn't fit your specific desires, don't expect an update to tailor the library to your personal, artistic liking - at that point, you're better off just taking the data output and using matplotlib to generate your own images. P.S. ATM, quick_graphs doesn't support libRL.characterization because of the sheer level of customization inherent to the function. I may add a feature at a later date to generate sets of graphs in a directory for each parameter, but to be frank, it's not too high on my list of priorities. quick_graph_reflection_loss libRL.quick_graphs.quick_graph_reflection_loss( results, location ) quick and dirty default graphing protocols for reflection loss. :param results: libRL.RL results of shape Nx3 :param location: string directory location of where to save the resulting graphical image. :return: None quick_graph_band_analysis libRL.quick_graphs.quick_graph_band_analysis( bands, d_vals, m_vals, location ) quick and dirty default graphing protocols for the band analysis. :param bands: band data passed through from the band_results derived from the cython computation. :param d_vals: d_set from libRL.refactoring() :param m_vals: m_set from libRL.refactoring() :param location: string directory location of where to save the resulting graphical image. :return: None","title":"quick_graphs.py"},{"location":"quick_graphs/#quick_graph_reflection_loss","text":"","title":"quick_graph_reflection_loss"},{"location":"quick_graphs/#quick_graph_band_analysis","text":"","title":"quick_graph_band_analysis"},{"location":"refactoring/","text":"refactoring.py file_refactor libRL.refactoring.file_refactor( data=None, **kwargs ) Refactors the given user data into an actionable permittivity and permeability array. :param data: (data) Permittivity and Permeability data of Nx5 dimensions. Can be a string equivalent to the directory and file name of either a .csv or .xlsx of Nx5 dimensions. Text above and below data array will be automatically avoided by the program (most network analysis instruments report data which is compatible with the required format) :param kwargs: :override=: (None); 'chi zero'; 'eps set' provides response simulation functionality within libRL, common for discerning which EM parameters are casual for reflection loss. 'chi zero' sets mu = (1 - j\u00b70). 'eps set' sets epsilon = (avg(e1)-j\u00b70). :return: (data) refactored data data of Nx5 dimensionality in numpy array interpolate libRL.refactoring.file_refactor( data=None, **kwargs ) uses SciPy's interpolation module to generate interpolating functions over the input data. :param data: (data) Permittivity data of Nx5 form where N rows are [frequency, e1, e2, mu1, mu2] :param kwargs: :interp=: ('cubic'); 'linear' Method for interpolation. Set to linear if user wants to linear interp instead of cubic spline. :return: e1f, e2f, mu1f, mu2f returns four functions for Real Permittivity, Complex Permittivity, Real Permeability, and Complex Permeability respectively f_set_ref libRL.refactoring.file_refactor( f_set, data ) refactors the input f_set to the corresponding Nx1 numpy array. :param f_set: (start, end, [step]) tuple for frequency values in GHz - or - if given as tuple of len 3, results are interpolated if given as tuple of len 2, results are data-derived with the calculation bound by the given start and end frequencies from the tuple is given as int or float of len 1, results are interpolated over the entire data set with a step size of the given tuple value. if f_set is None (default), frequency is bound to input data. :param data: (data) uses data as reference as frequencies are experimentally determined. :return: f_set refactored f_set of type Nx1 numpy array. d_set_ref libRL.refactoring.file_refactor( d_set ) refactors the input d_set to the corresponding Nx1 numpy array. :param d_set: (start, end, [step]) tuple for thickness values in mm. - or - if d_set is of type list, then the thickness values calculated will only be of the values present in the list. :return: d_set refactored d_set of type Nx1 numpy array. m_set_ref libRL.refactoring.file_refactor( m_set ) refactors the input m_set to the corresponding Nx1 numpy array. :param m_set: (start, end, [step]) tuple of ints which define the bands to be calculated. - or - if m_set is given as a list [], the explicitly listed band integers will be calculated. :return: m_set refactored m_set of type Nx1 numpy array. qgref libRL.refactoring.qgref( data ) grabs the passed directory location for image saving :param data: (r'C:\\file_directory') Accepts data as a variable before data refactoring to the permittivity and permeability array. As such, if data is passed as a file location, qgref grabs the directory string from the file location and saves resulting images at the directory. Else, the directory must be passed directly. :return: output_location output directory for subsequent graphical figures.","title":"refactoring.py"},{"location":"refactoring/#file_refactor","text":"","title":"file_refactor"},{"location":"refactoring/#interpolate","text":"","title":"interpolate"},{"location":"refactoring/#f_set_ref","text":"","title":"f_set_ref"},{"location":"refactoring/#d_set_ref","text":"","title":"d_set_ref"},{"location":"refactoring/#m_set_ref","text":"","title":"m_set_ref"},{"location":"refactoring/#qgref","text":"","title":"qgref"}]}